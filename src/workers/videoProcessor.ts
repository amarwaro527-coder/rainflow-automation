import { Job } from 'bullmq';
import { VideoEngine } from '../video-engine';
import path from 'path';
import fs from 'fs';
import { config } from '../config/env';

const engine = new VideoEngine();

export const videoProcessor = async (job: Job) => {
    console.log(`[VideoWorker] Processing job ${job.id}`);
    const { audioPath, videoSourcePath, seed, category } = job.data;

    try {
        // 1. Prepare paths
        const outputDir = path.join(config.paths.storage, 'final_output');
        const tempDir = path.join(config.paths.storage, 'temp_loops');

        if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });
        if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir, { recursive: true });

        // Default video source if not provided (for testing)
        const sourceVideo = videoSourcePath || path.join(config.paths.storage, 'raw_videos', 'default_rain.mp4');

        if (!fs.existsSync(sourceVideo)) {
            throw new Error(`Source video not found: ${sourceVideo}`);
        }

        // 2. Create Boomerang Loop (if not cached/exists)
        // We use a hash or simple naming convention for the loop base
        const loopName = `loop_base_${path.basename(sourceVideo, path.extname(sourceVideo))}.mp4`;
        const loopPath = path.join(tempDir, loopName);

        if (!fs.existsSync(loopPath)) {
            console.log(`[VideoWorker] Creating boomerang loop base...`);
            await engine.createBoomerangLoop(sourceVideo, loopPath);
        } else {
            console.log(`[VideoWorker] Using cached boomerang loop: ${loopPath}`);
        }

        // 3. Render Final Video
        const finalFileName = `rainflow_${category}_${seed}_${Date.now()}.mp4`;
        const finalPath = path.join(outputDir, finalFileName);

        console.log(`[VideoWorker] Rendering final video...`);
        await engine.renderFinalVideo(loopPath, audioPath, finalPath);

        console.log(`[VideoWorker] Success! Video at: ${finalPath}`);

        // Chain: Trigger Upload
        // In a real app, metadata would come from DB or AI generation step
        const uploadJob = await import('../queue/queues').then(m => m.uploadQueue.add('upload-video', {
            videoPath: finalPath,
            metadata: {
                title: `Relaxing Rain Sounds - ${category} - ${seed}`,
                description: 'Generated by Rainflow Automation Suite',
                tags: ['rain', 'sleep', 'relax'],
                publishAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString() // Schedule for tomorrow
            }
        }));
        console.log(`[VideoWorker] Triggered Upload Job: ${uploadJob.id}`);

        return { filePath: finalPath };

    } catch (error) {
        console.error(`[VideoWorker] Failed:`, error);
        throw error;
    }
};
